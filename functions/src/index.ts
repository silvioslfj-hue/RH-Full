/**
 * Import function triggers from their respective submodules:
 *
 * import {onCall} from "firebase-functions/v2/https";
 * import {onDocumentWritten} from "firebase-functions/v2/firestore";
 *
 * See a full list of supported triggers at https://firebase.google.com/docs/functions
 */

import {setGlobalOptions} from "firebase-functions/v2";
import {onCall, HttpsError} from "firebase-functions/v2/https";
import * as logger from "firebase-functions/logger";
import * as admin from "firebase-admin";

// Dependencies for eSocial integration
// const convert = require('xml-js');
// const forge = require('node-forge');
// const axios = require('axios');

// Secret Manager Client
import {SecretManagerServiceClient} from "@google-cloud/secret-manager";

// Initialize Firebase Admin SDK
admin.initializeApp();
const secretManagerClient = new SecretManagerServiceClient();


// For cost control, you can set the maximum number of containers that can be
// running at the same time. This helps mitigate the impact of unexpected
// traffic spikes by instead downgrading performance. This limit is a
// per-function limit. You can override the limit for each function using the
// `maxInstances` option in the function's options, e.g.
// `onRequest({ maxInstances: 5 }, (req, res) => { ... })`.
// NOTE: setGlobalOptions does not apply to functions using the v1 API. V1
// functions should each use functions.runWith({ maxInstances: 10 }) instead.
// In the v1 API, each function can only serve one request per container, so
// this will be the maximum concurrent request count.
setGlobalOptions({maxInstances: 10});

/**
 * Fetches a secret from Google Cloud Secret Manager.
 * @param {string} secretName The name of the secret to fetch.
 * @return {Promise<string>} The secret's value.
 */
async function getSecret(secretName: string): Promise<string> {
    const projectId = process.env.GCLOUD_PROJECT;
    if (!projectId) {
        throw new Error("Google Cloud project ID not available.");
    }

    const name = `projects/${projectId}/secrets/${secretName}/versions/latest`;

    try {
        const [version] = await secretManagerClient.accessSecretVersion({
            name: name,
        });

        const payload = version.payload?.data?.toString();
        if (!payload) {
            throw new Error(`Secret ${secretName} has no payload.`);
        }
        return payload;
    } catch (error) {
        logger.error(`Failed to access secret ${secretName}`, error);
        throw new HttpsError("internal", `Could not access secret for ${secretName}.`);
    }
}


/**
 * Handles the transmission of an eSocial event.
 * This function is triggered by a call from the client-side application.
 */
export const transmitirEventoESocial = onCall(async (request) => {
    // 1. Authentication and Authorization
    if (!request.auth) {
      throw new HttpsError("unauthenticated", "A função deve ser chamada por um usuário autenticado.");
    }
    // TODO: Add role-based access control (check if the user is an admin)
    // For example: const user = await admin.auth().getUser(request.auth.uid);
    // if (user.customClaims?.role !== 'admin') { ... }

    const eventId = request.data.eventId;
    if (!eventId) {
        throw new HttpsError("invalid-argument", "O ID do evento é obrigatório.");
    }

    const db = admin.firestore();
    const eventRef = db.collection("esocialEvents").doc(eventId);

    try {
        logger.info(`Processing eSocial event: ${eventId}`, {structuredData: true});
        await eventRef.update({status: "Processando"});

        // 2. Fetch Event and Related Data
        const eventDoc = await eventRef.get();
        if (!eventDoc.exists) {
            throw new HttpsError("not-found", `Evento com ID ${eventId} não foi encontrado.`);
        }
        const eventData = eventDoc.data();
        if (!eventData) {
            throw new HttpsError("not-found", "Dados do evento não encontrados.");
        }
        const companyId = eventData.companyId; // Assuming companyId is stored in the event

        // 3. Generate Structured Data (JSON)
        // In a real scenario, you'd re-run the AI generation here for security,
        // or trust the data generated and stored by the client-side flow.
        // For this example, we assume the AI already generated the necessary data.
        logger.info("Structured data already generated by client-side AI flow.", { eventId });

        // 4. Convert JSON to XML
        // TODO: Implement the logic to convert the event's JSON data to the eSocial XML format.
        // const jsonData = eventData.details; // Assuming JSON is in 'details'
        // const xmlString = convert.json2xml(jsonData, { compact: true, spaces: 4 });
        logger.info("TODO: Convert JSON to XML", { eventId });
        const xmlString = "<xml>Simulated XML content</xml>"; // Placeholder

        // 5. Fetch Certificate and Sign the XML
        const certName = `certs/${companyId}.pfx`;
        const secretName = `CERT_PASS_${companyId}`;
        logger.info(`Fetching certificate ${certName} and secret ${secretName}`, { eventId });
        
        // TODO: Implement logic to download certificate from Firebase Storage.
        // const certBuffer = await admin.storage().bucket().file(certName).download();
        
        // Fetch the certificate password from Secret Manager
        const certPassword = await getSecret(secretName);
        
        // TODO: Implement logic to sign the XML
        // const signedXml = signXml(xmlString, certBuffer, certPassword);
        logger.info("TODO: Sign XML using fetched certificate and password", { eventId, certPassword: "[REDACTED]" });
        const signedXml = `<xml>Simulated SIGNED XML content with password ${certPassword.substring(0,2)}...</xml>`; // Placeholder

        // 6. Transmit to eSocial API
        // TODO: Implement the API call to the eSocial webservice.
        // const esocialEndpoint = "https://webservices.producao.esocial.gov.br/...";
        // const response = await axios.post(esocialEndpoint, signedXml, { headers: { 'Content-Type': 'application/xml' } });
        logger.info("TODO: Transmit to eSocial API", { eventId });
        const receiptId = `mock_receipt_${Date.now()}`; // Placeholder

        // 7. Update Firestore with the result
        await eventRef.update({status: "Enviado", receiptId: receiptId, sentAt: new Date()});
        logger.info(`Event ${eventId} successfully sent.`, { receiptId });

        return {success: true, message: "Evento enviado com sucesso!", receiptId: receiptId};

    } catch (error) {
        logger.error(`Failed to process event ${eventId}`, error);
        await eventRef.update({status: "Erro", errorMessage: (error as Error).message});
        
        if (error instanceof HttpsError) {
            throw error;
        } else {
            throw new HttpsError("internal", `Ocorreu um erro inesperado ao processar o evento ${eventId}.`);
        }
    }
});
